---
title: 알고리즘의 분석과 시간 복잡도 및 공간 복잡도
tags: [Algorithm, Data Structure]
date: 
---

## 알고리즘의 분석

알고리즘은 문제를 해결하는 방법이라 볼 수 있다.
알고리즘의 자원(resoure) 사용량을 분석하는 것을 말한다. 여기서 자원이란 실행 시간, 메모리, 저장 장치, 통신대역등이 있지만 보통 소요 시간이 중요한 관심 대상이다. 보통의 알고리즘 분석이라고 말하는 것은 실행 시간에 대한, 시간 복잡도에 대한 것을 나타낸다.

좋은 알고리즘이라면 빠르게 실행되고 자원을 적게 사용하는 알고리즘일 것이다. 하지만 두 가지 모두를 만족 시키는 경우는 매우 드물고 과거에 비해 하드웨어의 비약적인 발전으로 상대적으로 공간 복잡도가 차지 하는 비중이 줄어들었다. 시간 복잡도가 좋게 나온다면 어느정도의 공간 복잡도는 무의미하다고 볼 수 있겠다.

여전히 임베디드 시스템나 빅데이터와 같이 용량이 중요한 분야도 있으며 대략적인 공간 복잡도에 대한 계산이 필요하기도 하다.

## 점근적 분석

점근적 표기법(asymptotic notation)은 데이터의 개수가 충분히 클 때 수행시간이 증가하는 비율을 시간 복잡도로 표현하는 기법이다. 빅오 표기법$O(n)$ 이나 세타 표기법$Θ(n)$ 등이 있다.
알고리즘의 효율성을 논할 때는 n이 충분히 클 때이므로 리미트를 이용한 분석이 점근적 분석 중 하나이다.

$\lim_{n \to\infty} \frac {2n^2 + 8n}{n}$

과 같을 경우 n이 충분히 커짐에 따라 $2n + 8$의 비율로 증가하는 것이다. 점근적 표기법에서는 상수항은 무시되고 최고차항만 나타내기 때문에 이 경우 빅오 표기법을 이용하면 $O(n)$과 같이 표기 된다.

### O-표기법

빅오 표기법이라고 하며 $O(n^2)$과 같이 표기하고 이 표기법은 해당 함수가 점근적 상한을 나타낸다. 이는 해당 알고리즘이 최악의 경우 $n^2$은 넘기지 않는다는 뜻이다.

### Θ-표기법

세타 표기법이라고 하며 $Θ(n^2)$과 같이 표기하고 이 표기법은 해당 함수의 상한과 하한사이에 존재하며 해당 알고리즘이 아무리 나쁘거나 좋아도 대략 $n^2$에 비례하는 시간이 소요됨을 뜻한다.

## 시간 복잡도

시간 복잡도(time complexity)는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 나타낸다. 실제 실행 시간은 실행 환경, 하드 웨어, OS, 언어 등에 따라 달라지게 되므로 알고리즘의 수행 시간은 입력의 크기에 대해 시간이 어떤 비율로 소요되는지로 표현한다.

```js
const add = n => n + 1;
```

`add`함수는 입력 n에 대해 n + 1을 리턴하는 것 뿐이므로 n의 크기와 관련 없이 상수 시간이므로 시간 복잡도는 $O(1)$로 나타낸다.

```js
const sum = (n) => {
    let ret = 0;
    for (let el of n) {
        ret += el;
    }
    return ret;
};
```

`sum`함수는 크기가 n인 배열을 받아서 그 크기 만큼 순회하며 덧셈 연산을 수행한다. for문 이외에는 상수 시간만큼만 소요되므로 for문이 n의 크기만큼 반복 되므로 수행 시간은 n에 비례한다. 따라서 시간 복잡도는 $O(n)$로 나타낸다.

## 공간 복잡도

공간 복잡도(space complexity)는 해당 프로그램이 실행된 후 완료하기 까지 필요한 자원(resource) 공간의 양이다. 일반적으로 여기서 말하는 자원은 메모리이다.

공간 복잡도는 전체 요구 공간 = 고정 요구 공간 + 가변 공간 요구로 나타낼 수 있으며 다음과 같이 표기 할 수 있다.

`$S(P) = c + Sp(n)$`

고정 공간은 입력과 출력의 횟수나 크기에 관계 없는 공간의 요구를 말한다. 예를 들면 코드의 저장 공간, 변수 나 상수 등의 할당 공간을 의미한다.

가변 공간은 프로그램이 실행 되는 동안 동적으로 필요한 공간을 말한다. 빅오 표기법에서는 상수항을 무시하기 때문에 공간 복잡도는 가변 공간에 의해 좌우된다.

```js
const sum = (a, b, c) => {
    return (a * b) + (a * c) + 2;
};
```

위 코드에서 number 타입의 변수 a, b, c가 있고 이 변수들이 64비트라고 한다면 총 192비트의 공간 복잡도라고 볼 수 있다. 그러나 이 변수들은 a, b, c 에 전달되는 인자(parameter)로 함수에서 해결하고자 하는 문제와 무관하다고 보므로 공간 복잡도는 0이다.

```js
const factorial = n => {
    if (n < 2) return 1;
    return n * factorial(n - 1);
};
```

`factorial`함수 재귀적으로 호출 되기 때문에 스택에 값들이 쌓이게 된다. 따라서 n부터 1까지의 값들이 쌓이게 되고 공간 복잡도는 변수 저장을 위한 n + 1개의 공간이 필요하므로 $O(n)$이 된다.

```js
const factorial = (n, acc) => {
    if (n < 2) return acc;
    return factorial(n - 1, acc * n);
};

const fac = n => factorial(n, 1);
```

꼬리 재귀를 통해서 구현한 `factorial`함수에서는 반환값에서 추가적인 연산이 필요 없기 때문에 스택에 쌓이지 않는다. 따라서 공간복잡도는 $O(1)$이다.