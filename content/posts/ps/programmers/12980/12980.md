---
title: "프로그래머스: 점프와 순간이동"
tags: [Problem Solving]
date: 2021-02-14T10:34:32.535Z
---

## 문제

문제 설명은 [여기](https://programmers.co.kr/learn/courses/30/lessons/12980)에서 볼수 있다.

## 첫 번째 풀이

0부터 시작해서 곱하고 더해서 `n`을 만드는 문제라고 생각해서 반대로 `n`이 2로 나누어 떨어질 때는 나누고 그렇지 않을 때는 1을 빼는 식으로 풀었다.

```js
const solution = n => {
    let count = 0;
    while (n) {
        if (!(n % 2)) {
            n = n / 2;
            continue;
        }
        n = n - 1;
        count += 1;
    }
    return count;
};
```

## 두 번째 풀이

다른 사람들 풀이를 보다가 띠용한 풀이법이 있었는데 2와 관련이 있다는 것은 알겠으나 정확히 왜 이렇게 되는 것인지 궁금하여 🤔생각해보았다.

```js
const solution = n => {
    let count = 0;
    while (n > 0) {
        n &= (n - 1);
        count += 1;
    }
    return count;
};
```

### 비트 연산자

|a|b|a & b|
|:---:|:---:|:---:|
|0|0|0|
|1|0|0|
|0|1|0|
|1|1|1|

비트 연산자는 `XOR`, `OR`, `AND`, `NOT` 등이 있는데 그 중 `AND`의 뜻을 가진 `&`는 두 비트 모두 `1`인 경우에만 `1`을 반환하고 그렇지 않으면 `0`을 반환한다.

### 이진법

십진법은 `0`부터 `9`까지의 10가지 숫자를 가지고 수를 나타낼 수 있는데 `9`의 다음 수는 `0`이 되고 그 앞자리의 수는 `1`만큼 증가하게 된다. 예컨대 `289`의 경우 그 다음 수는 `290`이 되는데 마지막 자리의 수가 `9`이므로 `0`이 되고 다음 자리 수인 `8`이 `1`만큼 증가하여 `9`가 된다. 자리가 증가할 때 마다 10배씩 차이가 나게되는데 `289`를 다시 아래와 같이 표기할 수 있다.

> $289 = 2×10^2 + 8×10^1 + 9×10^0$

이진법의 경우 `0`과 `1`로만 수를 나타내며 `1` 다음은 `0`을 `0` 다음은 `1`을 나타내게 된다. 십진수`13`을 이진법으로 변환했을 때 이진수 `1101`의 다음 수는 `1110`으로 마지막 자리의 수가 `1` 증가하여 해당 자리의 수는 `0`이 되고 그 다음자리의 수가 `1`로 증가하였다. 이진법도 십진법과 같이 풀어 나타내면 다음과 같다.

> $1101_2 = 1×2^3 + 1×2^2 + 0×2^1 + 1×2^0$

### 결론

먼저 `n`이 `5000`일 때 2로 더 이상 나누어 떨어지지 않을 때까지 계산해보면 다음과 같다.

|n|n/2|
|:---|:---|
|$5000$<br/>$1001110001000_2$|$2500$|
|$2500$<br/>$100111000100_2$|$1250$|
|$1250$<br/>$10011100010_2$|$625$|
|$625$<br/>$1001110001_2$|$312.5$|

`625`일 때 더 이상 나누어 떨어지지 않는데, 이 과정을 이진수로 나타내보면 하위 비트의 수가 하나씩 줄어들고 있다. 십진법에서 자리수가 1개 증가하면 10배 늘어나는 것처럼 이진법에서도 자리수가 1개 증가하면 2배 커지기 때문에 2로 나눌 경우 자리수가 1개씩 줄어드는 것이다.

최하위 비트가 `1`인 경우 홀수이므로 나누어 떨어지지 않을 때의 최하위 비트를 `0`으로 만드는 방법을 구하면 된다. 이진수 뺄셈에서 `0`에서 `1`을 뺄 수 없기 때문에 상위 비트에서 받아내려오는 것을 이용하면 된다. `24`에서 `7`을 빼는 과정은 아래와 같다.

```
    1 1 0 0 0
-       1 1 1
-------------

        2 2 2
    1 0 0 0 0
-       1 1 1
-------------

            1
    1 0 1 1 1
-       1 1 1
-------------
    1 0 0 0 1
```

즉, `n-1`을 사용하는 이유는 최하위 비트부터 가장 먼저 나타나는 `1`인 비트를 제거하기 위해 사용되는 것이다.

```
    1 1 0 0 0
&   1 0 1 1 1
-------------
    1 0 0 0 0
```

따라서 `n`이 `5000`일 때의 과정을 표로 나타내면 다음과 같다.

|n|n-1|n & (n-1)|
|:---|:---|:---|
|$5000_{10}$</br>$1001110001000_2$|$4999_{10}$<br/>$1001110000111_2$|$4992_{10}$<br/>$1001110000000_2$|
|$4992_{10}$</br>$1001110000000_2$|$4991_{10}$<br/>$1001101111111_2$|$4864_{10}$<br/>$1001100000000_2$|
|$4864_{10}$</br>$1001100000000_2$|$4863_{10}$<br/>$1001011111111_2$|$4608_{10}$<br/>$1001000000000_2$|
|$4608_{10}$</br>$1001000000000_2$|$4607_{10}$<br/>$1000111111111_2$|$4096_{10}$<br/>$1000000000000_2$|
|$4096_{10}$</br>$1000000000000_2$|$4095_{10}$<br/>$0111111111111_2$|$0$<br/>$0$|



결국 `n`의 이진수 값에서 `1`인 비트를 모두 지우는 과정이므로 `1`인 비트의 수를 구하면 된다.

```js
const solution = n => (n).toString(2).match(/1/g).length;
```

## 참조(References) 

- "이진법", <i>Wikipedia</i>, (Access: Feb, 14, 2021), https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84%EB%B2%95.